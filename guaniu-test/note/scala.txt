1. 变量定义
    var （非final）
    val （final,不可被重新赋值）

    scala中，变量或函数的类型总是写在变量或函数名称的后面，使得更容易阅读那些复杂类型的声明。
    scala中，仅当同一行代码中存在多条语句时，才需要分号隔开。


    scala中+-*/等操作符其实都是方法，scala的方法名没有必须是数字字母等限制。可以任意定义。

    a+b 是 a.+(b) 的简写，+是方法名。调用方法都是 对象.方法(args) ,java中也是这样的。
    通常 可以用
        a 方法 b     作为     a.方法(b)     的简写

    scala没有++ ，-- 这样的操作符（方法）

    scala一个类对应有一个伴生对象？？？

    不带参数的scala方法通常不适用圆括号
        如 "Hello".distinct     调用的是distinct()方法。


    apply方法
        是在类的伴生对象中定义
        使用伴生对象的apply方法是scala中构建对象的常用方法。
        BigInt("500")  其实就是  BigInt.apply("500")   的简写,用字符串产出一个新的BigInt对象，不需要new。


    scala 没有switch，但有强大的多的模式匹配。现阶段，用一系列if就好。

    scala 中，{}块包含一系列表达式，其结果也是一个表达式，块中最后一个表达式的值就是块的值。


循环：
    scala有while和do循环，但是没有直接和java对应的for(初始化变量;检查变量是否满足;更新变量)循环，而是
        for(变量 <- 表达式) 这样的循环。
    scala并没有提供break和continue来退出循环，使用boolean变量或嵌套函数的return或Breaks对象的break方法来实现。


scala的异常和java一样，必须是java.lang.Throwable的子类，不过，与java不同，scala没有“受检”异常(比如IO等必须处理的非runtimeexception)。你不需要
    声明说函数或方法可能会抛出某种异常。


2. 函数定义
    def 函数名(参数列表) : 返回值类型 = {
        ......
    }

    要定义函数，需给出函数名，参数和函数体。不过，只要函数不是递归，就不需要指定返回类型，scala会根据=右边推出返回类型。
    对于递归函数，必须指定返回类型。

3. 数组
    定长数组 Array
    变长数组 ArrayBuffer (类似java的list)
    数组循环 用for循环


类型参数化数组 array
    列表 list
    元组 tuple （包含不同类型元素）
    set和map






4. 识别函数式风格：如果代码包含了任何var变量，可能就是指令式风格，尝试不用var编程，或仅用val。

5. 类和对象
    class 定义的是类，是对象的蓝图，class定义的东西可以new
    object 是单例对象。


注意 main 的定义，与 Java 代码一样，是 Scala 程序可接受的输入点。它的定义，虽然看起来与 Java 的定义不同，实际上是等同的： main 接
受 String 数组作为参数且不返回任何值。但是，在 Scala 中，此定义看起来与 Java 版本稍有差异。 args 参数被定义为 args: Array[String]。
在 Scala 中，数组表示为泛型化的 Array 类的实例，这正是 Scala 使用方括号（ “[]”）而非尖括号（ “<>”）来指明参数化类型的原因。此外，为了保持
一致性，整个语言中都使用 name: type 的这种模式。
与其他传统函数语言一样， Scala 要求函数（在本例中为一个方法）必须始终返回一个值。因此，它返回称为 unit 的 “无值” 值。针对所有的实际目
的， Java 开发人员可以将 unit 看作 void，至少目前可以这样认为。
方法定义的语法似乎比较有趣，当它使用 = 操作符时，就像将随后的方法体赋值给 main 标识符。事实上，真正发生的事情是：在函数语言中，就像变量和
常量一样，函数是一级概念，所以语法上也是一样地处理。


6. junit 单元测试

    必须在class的方法def上才能进行@Test的测试，object中不能跑，不能只跑需要测试的方法
    但是main方法必须在object中才能运行，class中不行，class是对象的基础，是可以new的。
