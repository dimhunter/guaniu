问题

    2.8 节 ：_* 把参数转换成参数序列？
    2.12节 ：如果你不需要使用捕获的异常对象，可以使用 _ 来代替变量名？
    4.7   ： 如果并不是所有的部件都需要，可以在不需要的部件位置上使用_
    7.7   ： import java.awt._  ，在引入包的时候 _是表示全部，和java的*是一样的。
                引入包中几个成员是大括号，import java.awt.{Color,Font}



-------------------------------


更改新建的文件或类的头注释模式：settings - Editor - file and code templates - Includes - File Header

1. 变量定义
    var （非final）
    val （final,不可被重新赋值）

    scala中，变量或函数的类型总是写在变量或函数名称的后面，使得更容易阅读那些复杂类型的声明。
    scala中，仅当同一行代码中存在多条语句时，才需要分号隔开。


    scala中+-*/等操作符其实都是方法，scala的方法名没有必须是数字字母等限制。可以任意定义。

    a+b 是 a.+(b) 的简写，+是方法名。调用方法都是 对象.方法(args) ,java中也是这样的。
    通常 可以用
        a 方法 b     作为     a.方法(b)     的简写

    scala没有++ ，-- 这样的操作符（方法）

    scala一个类对应有一个伴生对象？？？

    不带参数的scala方法通常不适用圆括号
        如 "Hello".distinct     调用的是distinct()方法。


    apply方法
        是在类的伴生对象中定义
        使用伴生对象的apply方法是scala中构建对象的常用方法。
        BigInt("500")  其实就是  BigInt.apply("500")   的简写,用字符串产出一个新的BigInt对象，不需要new。


    scala 没有switch，但有强大的多的模式匹配。现阶段，用一系列if就好。

    scala 中，{}块包含一系列表达式，其结果也是一个表达式，块中最后一个表达式的值就是块的值。


循环：
    scala有while和do循环，但是没有直接和java对应的for(初始化变量;检查变量是否满足;更新变量)循环，而是
        for(变量 <- 表达式) 这样的循环。
    scala并没有提供break和continue来退出循环，使用boolean变量或嵌套函数的return或Breaks对象的break方法来实现。


scala的异常和java一样，必须是java.lang.Throwable的子类，不过，与java不同，scala没有“受检”异常(比如IO等必须处理的非runtimeexception)。你不需要
    声明说函数或方法可能会抛出某种异常。


2. 函数定义
    def 函数名(参数列表) : 返回值类型 = {
        ......
    }

    要定义函数，需给出函数名，参数和函数体。不过，只要函数不是递归，就不需要指定返回类型，scala会根据=右边推出返回类型。
    对于递归函数，必须指定返回类型。

3. 数组
    定长数组 Array
    变长数组 ArrayBuffer (类似java的list)
    数组循环 用for循环


    列表 list
    元组 tuple （包含不同类型元素）
    set和map


4. 类
    类中字段自动带有getter和setter方法
    类中方法就是def默认都是公有的，public的
    scala的类并不声明为public，scala源文件可以包含多个类，源文件名不必与类名相同。所有这些类都具有公有可见性。

    主构造器：1. 主构造器的参数直接放置在类名之后，参数被编译成字段，其值被初始化成构造时传入的参数。
                参数是val和var都可以，也可以不写。如果不写val或var，参数如何处理取决于他们在类中如何被使用。
             2. 主构造器会执行类定义中的所有语句。
             一个类如果没有显示定义主构造器，则自动拥有一个无参主构造器。
    辅助构造器：
        scala可以有任意多的构造器，不过只有一个主构造器，其他都是辅助构造器
        辅助构造器名称为this，和java是不同的，不必与类同名
        每个辅助构造器必须以一个先前已定义的其他辅助构造器或主构造器调用开始
        其实辅助构造器最终都会调用主构造器。

    无论是new主构造器，还是辅助构造器，都可以构建对象

    ！！！嵌套类，看书上，暂未整理。

5. 对象（就是scala中的单例object）
    单例对象：scala没有静态方法或静态字段，用object来实现。
        object用来作为单例或存放工具方法或常量的地方
        高效的共享单个不可变实例

    伴生对象
        java中，通常会用到既有实例方法又有静态方法的类，scala中，可以通过类(定义的class)和与类同名的伴生对象(定义的object)来达到同样目的。
        类class和他的伴生对象object可以相互访问私有特性，它们必须存在同一个源文件中。

    apply方法
        通常会在object中定义apply方法，apply方法会在如下形式表达式时，被调用。
            ObjectName(参数1，参数2，...,参数N),有了apply方法，就可以不用new来构造对象了
        一个object中apply方法可以有多个，参数不同即可

6. 枚举
    scala没有枚举，看书6.6节，未整理。

7. 继承
    extends,final关键字和java中相同
    重写方法时必须用override
    只有主构造器可以调用超类的主构造器
    可以重写字段
    如果类是final，就不能被扩展；方法或字段是final，不能被重写；
    scala中调用父类和java一样，用super

    抽象类和抽象字段，匿名子类，重写字段，看书8章即可。未整理，内容不多。


8.  sys.process.process包提供了和shell程序交互的工具。
    结尾 ! 操作符返回的结果是被执行程序的返回值：执行成功返回0，否则显示错误的非0值
    结尾 !! 输出会以字符串的形式返回。

9. 特质 trait
    实现特质用extends，不是implements，实现多个特质，其实后边是特质组，几个特质中间用with连接。
    抽象方法，不需要将方法声明为abstract，特质中未被实现的方法默认就是抽象的。抽象方法必须在子类中实现。
    特质的方法不一定都是抽象的，可以带有自己的实现，那么实现特质的子类就可以不重写这个实现了。

    new 对象时间可以混入不同的特质，很方便。虽然是相同的class，但是是不同对象，且不同对象分别实现了不同特质。


10. 操作符，一元，二元等，看书即可未总结


11.高阶函数 多看几遍书。重点SAM转换，柯里化，控制抽象


12.集合

    所有集合都扩展自Iterable特质，注意不是java那个，这里是scala的一个同名trait
    有3大类集合，序列seq，集合set，和映射map。都同时提供可变和不可变版本。


13. 模式匹配

    case    后可以跟任何类型。
    case _  匹配所有的默认
    case    可以加任何的boolean表达式，作为守卫
    case *  如果case后跟一个变量名，那么匹配的表达式会被赋值给那个变量。
            可以匹配类型模式，比如String，Int等

    提取器，书上未总结。






4. 识别函数式风格：如果代码包含了任何var变量，可能就是指令式风格，尝试不用var编程，或仅用val。

5. 类和对象
    class 定义的是类，是对象的蓝图，class定义的东西可以new
    object 是单例对象。




注意 main 的定义，与 Java 代码一样，是 Scala 程序可接受的输入点。它的定义，虽然看起来与 Java 的定义不同，实际上是等同的： main 接
受 String 数组作为参数且不返回任何值。但是，在 Scala 中，此定义看起来与 Java 版本稍有差异。 args 参数被定义为 args: Array[String]。
在 Scala 中，数组表示为泛型化的 Array 类的实例，这正是 Scala 使用方括号（ “[]”）而非尖括号（ “<>”）来指明参数化类型的原因。此外，为了保持
一致性，整个语言中都使用 name: type 的这种模式。
与其他传统函数语言一样， Scala 要求函数（在本例中为一个方法）必须始终返回一个值。因此，它返回称为 unit 的 “无值” 值。针对所有的实际目
的， Java 开发人员可以将 unit 看作 void，至少目前可以这样认为。
方法定义的语法似乎比较有趣，当它使用 = 操作符时，就像将随后的方法体赋值给 main 标识符。事实上，真正发生的事情是：在函数语言中，就像变量和
常量一样，函数是一级概念，所以语法上也是一样地处理。


6. junit 单元测试

    必须在class的方法def上才能进行@Test的测试，object中不能跑，不能只跑需要测试的方法
    但是main方法必须在object中才能运行，class中不行，class是对象的基础，是可以new的。
